# Creational (Порождающие)

**Abstract Factory**

1. Абстрактная фабрика создающая абстрактные продукты
2. Конкретные продукты, реализующие абстрактные
3. Конкретные фабрики, реализующие абстрактные, создающие конкретные объекты с интерфейсом абстрактных

**Builder**

*Вариант I:*

1. Некий базовый объект, который может иметь дефолтные параметры
2. Внутренний класс, который конструирует этот объект

*Вариант II (по Банде 4-ех):*

1. Абстрактный класс, строящий в отдельном методе итоговый продукт, отдельно его зависмости
2. Метод getProduct(), возвращающий текущий объект на момент крепления к нему всех зависимостей
(Пример с лабиринтом, дверьми, комнатами и стенами)

*Note:* отличается от AF тем, что строитель пошагово конструирует объект и позволяет его дополнить в процессе, тогда как AF выдает готовый результат

**Factory Method**

*Вариант I:* статический метод, замещающий конструктор (может содержат дополнительное поведение)

*Вариант II:** отдельный класс (или абстракция) Creator с **ЕДИНСТВЕННЫМ** статическим, либо с обычным методом, возвращающий разновидность объектов (абстракцию) либо дженерик

**Prototype**

Трейт Prototype или Clone, клонирующий объект с помощью метода clone()

**Singleton**

Инициализирует единственную статическую сущность объекта в статическом методе, запрещает создание новых сущностей. Весь функционал работает только через Singleton::get_instance().method_call()

# Structural

**Adapter (Wrapper)**

*Вариант I:* оборачивает один класс и реализует другой класс (пример: обернуть треугольник в TriangularSquare и реализовать Square трейт)

```Kotlin
class TriangularSquare(private val triangle: Triangle) : Square
```

*Вариант II:* множественное наследование в плюсах через

```C++
class triangular_square : public square, private triangle {}
```

**Bridge**

Отделить абстракцию от реализации, чтобы изменять обе независимо друг от друга

1. Абстракция, хранящаяя ссылку на абстрактную реализацию и абстрактный метод get_impl()
2. Абстрактная реализация НЕ РЕАЛИЗУЮЩАЯ абстракцию
3. Конкретные классы, реализующие обе абстракции

**Composite (Компоновщик)**

Для создания древовидных структур (пример: меню, подменю, действия)

1. Абстракция Component, которую все реализуют
2. Leaf : Component, у которого не будет дочерних компонент
3. Composite : Component, у которого есть дочерние компоненты (хранятся в некой структуре данных)

**Decorator**

Динамически добавляет объекту новые свойства

1. Abstraction
2. Concrete : Abstraction
3. AbstractDecorator(Abstraction) : Abstraction
4. ConcreteDecorator(Abstraction) : AbstractDecorator(Abstraction) { fun decoratorFeature() }

**Facade**

Ослабить использование объектов другими объектами путем выделения объекта-фасада, который всем управляет

1. Независимые компоненты, которые делают свое дело и не хранят ссылок **НИ на другие компоненты, НИ НА САМ ФАСАД**

2. Фасад, который объединяет работу всех компонентов, словно дирижер

*Note:* отличается от Mediator-a тем, что **отношения односторонние**

**Flyweight (Приспособленец)**
*Фабрика одиночек*

Помогает сократить расходы памяти, если объектов слишком много, путем их кеширования

1. Объект, использование которого хотим кешировать
2. Объект с уникальным словарем объектов, где по ключу мы либо достаем существующий объект, либо хешируем в словаре

**Proxy/Surrogate (Заместитель)**
*Placeholder*

Замещает тяжелый в создании и инициализации объект, пока может (пример: картинка и метаданные)

1. Трейт с методами
2. Конкретный объект, создать который достаточно ресурсоемко
3. Proxy, который может заместить конкретный объект на некоторых запросах (например, метаданные)

# Behaviour

**Chain of Responsibility**

Перекладывание ответственности по дереву (цепи)

1. Трейт с функционалом, который будет отправлен по цепочке до корня (или раньше) (e.g. RequestHandler с методом handleRequest())
2. Иерархическая структура, где все реализуют этот трейт
3. Компонент иерархии, запуская handleRequest(), вызывает предка, который запускает свой handleHelp() и переходит к своему предку и так далее, пока не дойдем до нужного компонента

**Command/Action/Transaction**

Обертка над callback-ом (функцией)

1. Абстракция с методом запуска (execute/invoke/run и т.п.) и отмены (unexecute, cancel и т.п.)
2. Конкретные объекты с реализацией метода
3. (Опционально) Макро-комманды, использующие под-комманды

**Interpreter**

Парсинг и обработка языков

1. Глобальный Context - парсит и осмысливает выражения
2. AbstractExpression с методом interpert()
3. TerminalExpression - простое однозначное выражение (не вложено, например, символы, скобки, и тд)
4. NonTerminalExpression - вложенные рекурсивные выражения (хранит ссылки на дочерние AbstractExpression)

**Iterator**

Позволяет обходить структуру данных в соответствии с алгоритмом поска следующего/предыдущего элемента.

1. Структура данных
2. Iterator с методом next(), get() и другими опциональными методами

**Mediator/Director (Посредник)**

Ослабляет ссылаемость объектов друг на друга, становлясь между ними

1. Mediator/Director - определяет интерфейс взаимодействия между объектами, хранит на всех ссылки
2. Collegue - хранят ссылку ТОЛЬКО на Mediator, общаются только через него

Пример:
1) Диалоговое окно, которое обрабатывает изменения дочерних виджетов. Имеет метод widgetChanged(Widget), которое заставляет другие виджеты обновляться.
2) У каждого виджета есть метод onChange() { dialogDirector.widgetChanged(this) }

*Note:* отличается от Фасада тем, что отношения между посредником и коллегами **двухсторонние**

**Memento/Snapshot (Хранитель/Снимок)**

Сохранение и откат состояний, не нарушая инкапсуляции

1. State - хранит некое состояние программы
2. Memento - хранит информацию о снимке, приватно для Originator-а позволяет переназначить состояние и получить его
3. Caretaker (Опекун) - сохраняет предыдущие состояния
4. Originator (Создаетль) - объект, состояния которого сохраняет опекун. Хранит текущее состояние, создает новые снимки createMemento() и обновляет текущее состояние через снимок setMemento()

**Observer**

Обновляет подписчиков, посылая сигналы

1. AbstractSubject - абстракция, хранящая Option<Observer> c методами
 subscribe(Observer) { this.observer = observer; observer.addSubscriber(this) },  
 unsubscribe(Observer) { this.observer = none; observer.removeSubscriber(this) },
 notify() { observer.update() }

2. ConcreteSubject - реализует AbstractSubject и хранит свои состояния и методы
3. Observer - хранит список подписчиков и обновляет их после дочернего вызова subscriber.notify()

**State**

Выполнить блок кода, если случилось некое условие (заменить if/else)

1. Трейт State с методом handle/execute
2. Конкретные состояния с реализацией метода handle/execute
3. Context - запускает состояния (через handle), если условие запуска наступает

**Strategy**

Структурирует схожие по назначению алгоритмы внутри отдельных объектов

1. Трейт Strategy - запустит алгоритм-метод с некими аргументами, одинаковыми для всех стратегий
2. ConcreteStrategy - реализует Strategy и запускает конкретный алгоритм
1. Context/Composition - хранит ссылку на абстрактную стратегию и запускает ее

**Template Method**

Абстракция с дефолтной реализацией функционала, которую нельзя переопределить

1. AbstractObject с final doDefaultBreakfast() { варить_каша(); пить_чай(); }
2. Конкретный объект, использующий doDefault(), если нужно

**Visitor**

Объединяет схожие алгоритмы объектов, не связанных друг с другом никаким родством

1. Visitor { visit(ElementA); visit(ElementB) }, оба visit-а выполняют схожие по смыслу действия
2. Конкретные ElementA и ElementB, не связанные друг с другом достаточно сильно, чтобы использовать visit(AbstractElement)
